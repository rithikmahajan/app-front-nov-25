/**
 * FAQ Screen with Backend API Integration
 * 
 * This component fetches FAQ data from the Yoraa backend API and displays it in an accordion-style interface.
 * 
 * Backend API Details:
 * - Base URL (Production): https://yoraa.in.net
 * - Endpoint: GET /api/faqs
 * - Full URL: https://yoraa.in.net/api/faqs
 * - Timeout: 20 seconds
 * - No authentication required for reading FAQs
 * 
 * Expected API Response Format (from backend team):
 * {
 *   success: true,
 *   message: "FAQs retrieved successfully",
 *   data: [
 *     {
 *       _id: string,
 *       title: string,        // Mapped to 'question' in frontend
 *       detail: string,       // Mapped to 'answer' in frontend
 *       category: string,
 *       isActive: boolean,
 *       priority: number
 *     }
 *   ],
 *   pagination: {
 *     page: number,
 *     total: number
 *   }
 * }
 * 
 * Features:
 * - Direct fetch from backend API (bypassing YoraaAPIClient for better error handling)
 * - Pull-to-refresh functionality
 * - Comprehensive loading states and error handling
 * - Expandable/collapsible FAQ items
 * - Retry functionality for failed API calls
 * - Field mapping (titleâ†’question, detailâ†’answer)
 * - Active FAQ filtering (only shows isActive=true FAQs)
 * - Enhanced logging for debugging
 * - 20-second timeout as recommended by backend team
 */

import React, { useState, useEffect } from 'react';
import {
  View,
  Text,
  StyleSheet,
  ScrollView,
  TouchableOpacity,
  SafeAreaView,
  ActivityIndicator,
  Alert,
  RefreshControl,
} from 'react-native';
import GlobalBackButton from '../components/GlobalBackButton';
import { YoraaAPI } from '../../YoraaAPIClient';

// Plus/Minus Icon Component
const ExpandIcon = ({ isExpanded }) => (
  <View style={styles.iconContainer}>
    {/* Horizontal line */}
    <View style={styles.horizontalLine} />
    {/* Vertical line - hidden when expanded */}
    {!isExpanded && <View style={styles.verticalLine} />}
  </View>
);

const FAQScreen = ({ navigation }) => {
  // State management
  const [expandedItems, setExpandedItems] = useState({});
  const [faqData, setFaqData] = useState([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  // Fetch FAQ data from backend
  useEffect(() => {
    const fetchFAQs = async () => {
      try {
        console.log('[FAQ] ðŸ” Starting to fetch FAQs from backend...');
        console.log('[FAQ] ðŸ“¡ API Base URL:', YoraaAPI.baseURL);
        setLoading(true);
        setError(null);
        
        // Initialize API client
        await YoraaAPI.initialize();
        
        // Direct fetch using the correct endpoint format
        // Backend expects: GET https://yoraa.in.net/api/faqs
        const fullUrl = `${YoraaAPI.baseURL}/api/faqs`;
        console.log('[FAQ] ðŸ“¡ Fetching from:', fullUrl);
        
        const response = await fetch(fullUrl, {
          method: 'GET',
          headers: {
            'Content-Type': 'application/json',
            'Accept': 'application/json',
          },
          timeout: 20000, // 20 second timeout as recommended
        });

        console.log('[FAQ] âœ… Response status:', response.status);
        
        if (!response.ok) {
          throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }

        const data = await response.json();
        console.log('[FAQ] ðŸ“¦ API Response received:', JSON.stringify(data).substring(0, 200) + '...');
        
        // Handle backend response format according to API guide
        // Expected format: { success: true, message: "...", data: [...], pagination: {...} }
        let faqs = [];
        
        // Primary format: response.data (array of FAQs)
        if (data?.success && data?.data && Array.isArray(data.data)) {
          console.log('[FAQ] âœ… Found FAQs in data.data (standard format), count:', data.data.length);
          faqs = data.data;
        }
        // Fallback: Direct array
        else if (Array.isArray(data)) {
          console.log('[FAQ] âœ… Response is direct array, count:', data.length);
          faqs = data;
        }
        // Fallback: response.faqs
        else if (data?.faqs && Array.isArray(data.faqs)) {
          console.log('[FAQ] âœ… Found FAQs in data.faqs, count:', data.faqs.length);
          faqs = data.faqs;
        }
        else {
          console.warn('[FAQ] âš ï¸ Unexpected FAQ response format:', JSON.stringify(data));
          throw new Error('Invalid response format from server');
        }
        
        // Map FAQ fields (backend uses title/detail, frontend uses question/answer)
        const mappedFaqs = faqs.map((faq, index) => ({
          id: faq._id || faq.id || `faq-${index}`,
          question: faq.question || faq.title || 'No question',
          answer: faq.answer || faq.detail || 'No answer',
          category: faq.category || 'general',
          isActive: faq.isActive !== undefined ? faq.isActive : true,
          priority: faq.priority || index,
        }));
        
        // Filter only active FAQs
        const activeFaqs = mappedFaqs.filter(faq => faq.isActive);
        
        console.log('[FAQ] âœ… Total FAQs:', faqs.length);
        console.log('[FAQ] âœ… Active FAQs:', activeFaqs.length);
        console.log('[FAQ] âœ… First FAQ:', activeFaqs[0]?.question || 'None');
        
        if (activeFaqs.length === 0) {
          console.warn('[FAQ] âš ï¸ No active FAQs available');
          setError('No FAQs available at the moment.');
        }
        
        setFaqData(activeFaqs);
        console.log('[FAQ] âœ… FAQs loaded successfully. Total active count:', activeFaqs.length);
      } catch (apiError) {
        console.error('[FAQ] âŒ Error fetching FAQs:', apiError);
        console.error('[FAQ] âŒ Error details:', {
          message: apiError.message,
          name: apiError.name,
          stack: apiError.stack,
        });
        
        let errorMessage = 'Unable to load FAQs from server';
        
        // Provide specific error messages based on error type
        if (apiError.message.includes('Network request failed') || apiError.name === 'TypeError') {
          errorMessage = 'Cannot connect to server. Please check:\n1. Your internet connection\n2. Backend server is running\n3. VPN if applicable';
        } else if (apiError.message.includes('timeout')) {
          errorMessage = 'Request timeout. Server is taking too long to respond.';
        } else if (apiError.message.includes('404')) {
          errorMessage = 'FAQ endpoint not found. Please contact support.';
        } else if (apiError.message.includes('500')) {
          errorMessage = 'Server error. Please try again later.';
        } else {
          errorMessage = apiError.message || errorMessage;
        }
        
        setError(errorMessage);
        setFaqData([]);
        
        // Show error alert with retry option
        Alert.alert(
          'FAQ Loading Error',
          errorMessage,
          [
            { text: 'OK', style: 'default' },
            { 
              text: 'Retry', 
              style: 'cancel',
              onPress: () => {
                // Reload component
                setLoading(true);
                setTimeout(() => fetchFAQs(), 100);
              }
            }
          ]
        );
      } finally {
        setLoading(false);
      }
    };

    fetchFAQs();
  }, []);

  const toggleItem = (itemId) => {
    setExpandedItems(prev => ({
      ...prev,
      [itemId]: !prev[itemId]
    }));
  };

  const refreshFAQs = async () => {
    try {
      console.log('[FAQ] ðŸ”„ Refreshing FAQs...');
      setLoading(true);
      setError(null);
      
      await YoraaAPI.initialize();
      
      // Direct fetch using the correct endpoint format
      const fullUrl = `${YoraaAPI.baseURL}/api/faqs`;
      console.log('[FAQ] ðŸ“¡ Refresh - Fetching from:', fullUrl);
      
      const response = await fetch(fullUrl, {
        method: 'GET',
        headers: {
          'Content-Type': 'application/json',
          'Accept': 'application/json',
        },
        timeout: 20000,
      });

      console.log('[FAQ] âœ… Refresh - Response status:', response.status);
      
      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }

      const data = await response.json();
      console.log('[FAQ] ðŸ“¦ Refresh - API Response received');
      
      // Handle backend response format
      let faqs = [];
      
      if (data?.success && data?.data && Array.isArray(data.data)) {
        console.log('[FAQ] âœ… Refresh - Found FAQs in data.data, count:', data.data.length);
        faqs = data.data;
      } else if (Array.isArray(data)) {
        console.log('[FAQ] âœ… Refresh - Response is direct array, count:', data.length);
        faqs = data;
      } else if (data?.faqs && Array.isArray(data.faqs)) {
        console.log('[FAQ] âœ… Refresh - Found FAQs in data.faqs, count:', data.faqs.length);
        faqs = data.faqs;
      } else {
        console.warn('[FAQ] âš ï¸ Refresh - Unexpected response format');
        throw new Error('Invalid response format from server');
      }
      
      // Map FAQ fields
      const mappedFaqs = faqs.map((faq, index) => ({
        id: faq._id || faq.id || `faq-${index}`,
        question: faq.question || faq.title || 'No question',
        answer: faq.answer || faq.detail || 'No answer',
        category: faq.category || 'general',
        isActive: faq.isActive !== undefined ? faq.isActive : true,
        priority: faq.priority || index,
      }));
      
      // Filter only active FAQs
      const activeFaqs = mappedFaqs.filter(faq => faq.isActive);
      
      console.log('[FAQ] âœ… Refresh - Active FAQs loaded:', activeFaqs.length);
      
      if (activeFaqs.length === 0) {
        setError('No FAQs available at the moment.');
      }
      
      setFaqData(activeFaqs);
    } catch (apiError) {
      console.error('[FAQ] âŒ Error refreshing FAQs:', apiError);
      
      let errorMessage = 'Unable to refresh FAQs';
      
      if (apiError.message.includes('Network request failed') || apiError.name === 'TypeError') {
        errorMessage = 'Cannot connect to server. Check your connection.';
      } else if (apiError.message.includes('timeout')) {
        errorMessage = 'Request timeout. Please try again.';
      } else {
        errorMessage = apiError.message || errorMessage;
      }
      
      setError(errorMessage);
      setFaqData([]);
    } finally {
      setLoading(false);
    }
  };

  // Method to fetch FAQs by category if needed (for future use)
  // eslint-disable-next-line no-unused-vars
  const fetchFAQsByCategory = async (category) => {
    try {
      console.log(`[FAQ] Fetching FAQs for category: ${category}`);
      await YoraaAPI.initialize();
      const response = await YoraaAPI.getFAQsByCategory(category);
      
      if (response && response.faqs && Array.isArray(response.faqs)) {
        setFaqData(response.faqs);
      } else if (response && Array.isArray(response)) {
        setFaqData(response);
      }
    } catch (apiError) {
      console.error('Error fetching FAQs by category:', apiError);
      setError(YoraaAPI.handleError(apiError));
    }
  };

  // Method to fetch individual FAQ details if needed (for future use)
  // eslint-disable-next-line no-unused-vars
  const fetchFAQById = async (faqId) => {
    try {
      console.log(`[FAQ] Fetching FAQ details for ID: ${faqId}`);
      await YoraaAPI.initialize();
      const response = await YoraaAPI.getFAQById(faqId);
      console.log(`[FAQ] FAQ details response:`, response);
      return response;
    } catch (apiError) {
      console.error('Error fetching FAQ by ID:', apiError);
      return null;
    }
  };

  const handleBack = () => {
    console.log('[FAQ] Back button pressed, navigating to Profile');
    if (navigation && navigation.navigate) {
      console.log('[FAQ] Navigation object exists, calling navigate');
      navigation.navigate('Profile');
    } else {
      console.log('[FAQ] Navigation object missing or navigate method not available');
    }
  };

  return (
    <SafeAreaView style={styles.container}>
      {/* Header */}
      <View style={styles.header}>
        <View style={styles.backButton}>
          <GlobalBackButton 
            navigation={navigation} 
            onPress={handleBack}
            accessibilityRole="button"
            accessibilityLabel="Go back"
          />
        </View>
        <Text style={styles.headerTitle}>FAQ</Text>
        <View style={styles.headerRight} />
      </View>

      {/* FAQ Content */}
      <ScrollView 
        style={styles.scrollView} 
        contentContainerStyle={styles.scrollContentContainer}
        showsVerticalScrollIndicator={false}
        refreshControl={
          <RefreshControl
            refreshing={loading}
            onRefresh={refreshFAQs}
            colors={['#000000']}
            tintColor="#000000"
          />
        }
      >
        {loading && (
          <View style={styles.loadingContainer}>
            <ActivityIndicator size="large" color="#000000" />
            <Text style={styles.loadingText}>Loading FAQs...</Text>
          </View>
        )}
        
        {error && !loading && (
          <View style={styles.errorContainer}>
            <Text style={styles.errorText}>
              Failed to load FAQs from server. Please check your connection and try again.
            </Text>
            <TouchableOpacity style={styles.retryButton} onPress={refreshFAQs}>
              <Text style={styles.retryButtonText}>Retry</Text>
            </TouchableOpacity>
          </View>
        )}
        
        {!loading && !error && faqData.length === 0 && (
          <View style={styles.emptyContainer}>
            <Text style={styles.emptyText}>
              No FAQs available at the moment.
            </Text>
            <TouchableOpacity style={styles.retryButton} onPress={refreshFAQs}>
              <Text style={styles.retryButtonText}>Refresh</Text>
            </TouchableOpacity>
          </View>
        )}
        
        {faqData.map((item, index) => {
          // Use item.id if available, otherwise use index as fallback
          const itemId = item.id !== undefined ? item.id : `faq-${index}`;
          
          return (
            <View key={itemId} style={styles.faqItem}>
              <TouchableOpacity 
                style={styles.questionContainer} 
                onPress={() => toggleItem(itemId)}
                accessibilityRole="button"
                accessibilityLabel={`Toggle FAQ: ${item.question}`}
                accessibilityState={{ expanded: expandedItems[itemId] }}
              >
                <Text style={styles.questionText}>{item.question}</Text>
                <ExpandIcon isExpanded={expandedItems[itemId]} />
              </TouchableOpacity>
              
              {expandedItems[itemId] && (
                <View style={styles.answerContainer}>
                  <Text style={styles.answerText}>{item.answer}</Text>
                </View>
              )}
            </View>
          );
        })}
      </ScrollView>
    </SafeAreaView>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#FFFFFF',
  },
  
  // Header Styles
  header: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
    paddingHorizontal: 16,
    paddingTop: 16,
    paddingBottom: 12,
    backgroundColor: '#FFFFFF',
  },
  backButton: {
    width: 68,
    alignItems: 'flex-start',
  },
  headerTitle: {
    fontSize: 16,
    fontWeight: '500',
    color: '#000000',
    textAlign: 'center',
    letterSpacing: -0.4,
    fontFamily: 'Montserrat-Medium',
  },
  headerRight: {
    width: 68,
  },

  // Content Styles
  scrollView: {
    flex: 1,
    paddingHorizontal: 32,
  },
  scrollContentContainer: {
    paddingBottom: 100,
  },
  faqItem: {
    marginBottom: 16,
  },
  questionContainer: {
    flexDirection: 'row',
    alignItems: 'flex-start',
    justifyContent: 'space-between',
    paddingVertical: 8,
    paddingRight: 4,
  },
  questionText: {
    fontSize: 14,
    fontWeight: '600',
    color: '#000000',
    lineHeight: 16.8, // 1.2 line height
    flex: 1,
    marginRight: 16,
    fontFamily: 'Montserrat-SemiBold',
  },
  answerContainer: {
    marginTop: 8,
    paddingRight: 20,
  },
  answerText: {
    fontSize: 14,
    fontWeight: '500',
    color: '#848688',
    lineHeight: 16.8, // 1.2 line height
    fontFamily: 'Montserrat-Medium',
  },

  // Loading and Error Styles
  loadingContainer: {
    flex: 1,
    alignItems: 'center',
    justifyContent: 'center',
    paddingVertical: 60,
  },
  loadingText: {
    fontSize: 14,
    fontWeight: '500',
    color: '#848688',
    marginTop: 12,
    fontFamily: 'Montserrat-Medium',
  },
  errorContainer: {
    backgroundColor: '#FFF3CD',
    borderLeftWidth: 4,
    borderLeftColor: '#FFC107',
    padding: 12,
    marginBottom: 16,
    borderRadius: 4,
  },
  errorText: {
    fontSize: 13,
    fontWeight: '500',
    color: '#856404',
    fontFamily: 'Montserrat-Medium',
    marginBottom: 8,
  },
  emptyContainer: {
    flex: 1,
    alignItems: 'center',
    justifyContent: 'center',
    paddingVertical: 60,
  },
  emptyText: {
    fontSize: 14,
    fontWeight: '500',
    color: '#848688',
    textAlign: 'center',
    marginBottom: 16,
    fontFamily: 'Montserrat-Medium',
  },
  retryButton: {
    backgroundColor: '#FFC107',
    paddingHorizontal: 16,
    paddingVertical: 8,
    borderRadius: 4,
    alignSelf: 'flex-start',
  },
  retryButtonText: {
    fontSize: 12,
    fontWeight: '600',
    color: '#856404',
    fontFamily: 'Montserrat-SemiBold',
  },

  // Icon Styles
  iconContainer: {
    width: 16,
    height: 16,
    alignItems: 'center',
    justifyContent: 'center',
    position: 'relative',
  },
  horizontalLine: {
    width: 11,
    height: 1.5,
    backgroundColor: '#000000',
    borderRadius: 0.75,
  },
  verticalLine: {
    width: 1.5,
    height: 11,
    backgroundColor: '#000000',
    borderRadius: 0.75,
    position: 'absolute',
  },
});

export default FAQScreen;
